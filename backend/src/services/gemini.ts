// Gemini AI Service for KZ Connect Studio
// Generates event posters with context-aware Kazakhstan city themes
// Provider: Google Gemini (gemini-2.0-flash, imagen-3.0-generate-002)

import { GoogleGenerativeAI } from '@google/generative-ai';

export interface EventDetails {
  title: string;
  tagline: string;
  date: string;
  location: string;
  description: string;
  theme: string;
}

export interface RefinedEventDetails extends EventDetails {
  imagePrompt: string;
}

export interface PosterGenerationRequest {
  title: string;
  date: string;
  location: string;
  description?: string;
  theme: PosterTheme;
}

export interface PosterGenerationResult {
  imageUrl: string;
  details: RefinedEventDetails;
  // Kazakhstan AI Law compliance
  isAiGenerated: true;
  aiDisclaimer: string;
  generatedAt: string;
  provider: 'gemini';
}

export type PosterTheme =
  | 'modern-nomad'    // Этно-футуризм
  | 'urban-pulse'     // Мегаполис
  | 'great-steppe'    // Природа и простор
  | 'cyber-shanyrak'  // Технологии
  | 'silk-road';      // Классика и история

// Kazakhstan AI Law - mandatory disclosure
export const AI_DISCLAIMER_KZ = 'Бұл сурет жасанды интеллект арқылы жасалған';
export const AI_DISCLAIMER_RU = 'Изображение сгенерировано искусственным интеллектом';
export const AI_DISCLAIMER_EN = 'This image was generated by artificial intelligence';

export const AI_VIDEO_DISCLAIMER_KZ = 'Бұл бейне жасанды интеллект арқылы жасалған';
export const AI_VIDEO_DISCLAIMER_RU = 'Видео сгенерировано искусственным интеллектом';
export const AI_VIDEO_DISCLAIMER_EN = 'This video was generated by artificial intelligence';

// Video generation types
export interface VideoGenerationRequest {
  title: string;
  date: string;
  location: string;
  description?: string;
  theme: PosterTheme;
  duration?: '4s' | '8s'; // Veo 2 supports 4 and 8 seconds
  aspectRatio?: '16:9' | '9:16'; // Landscape or Portrait
  sourceImage?: string; // Base64 image for image-to-video
}

export interface VideoGenerationResult {
  videoUrl: string;
  thumbnailUrl?: string;
  duration: string;
  aspectRatio: string;
  details: RefinedEventDetails;
  // Kazakhstan AI Law compliance
  isAiGenerated: true;
  aiDisclaimer: string;
  generatedAt: string;
  provider: 'gemini-veo';
}

// Theme descriptions for visual prompts
const THEME_CONFIGS: Record<PosterTheme, { name: string; visualStyle: string; colors: string }> = {
  'modern-nomad': {
    name: 'Modern Nomad',
    visualStyle: 'ethno-futurism, traditional Kazakh patterns reimagined in modern minimalist style, subtle shanyrak elements, nomadic heritage meets contemporary design',
    colors: 'gold and deep blue, warm earth tones with modern accents',
  },
  'urban-pulse': {
    name: 'Urban Pulse',
    visualStyle: 'metropolitan cityscape, modern architecture, dynamic urban energy, night city lights, glass and steel',
    colors: 'neon accents on dark backgrounds, electric blue and purple, city lights glow',
  },
  'great-steppe': {
    name: 'Great Steppe',
    visualStyle: 'vast Kazakh steppe landscape, dramatic sky, mountains, natural beauty, open spaces, eagles, horses',
    colors: 'natural greens and browns, golden sunset tones, clear blue sky',
  },
  'cyber-shanyrak': {
    name: 'Cyber Shanyrak',
    visualStyle: 'technological futurism, digital elements, circuit patterns inspired by traditional ornaments, holographic effects, AI and innovation',
    colors: 'cyan and magenta, digital gradients, glowing tech accents',
  },
  'silk-road': {
    name: 'Silk Road',
    visualStyle: 'classical elegance, historical architecture, oriental patterns, ancient trade route heritage, traditional craftsmanship',
    colors: 'rich burgundy and gold, warm amber, antique tones',
  },
};

// City-specific context for better localization
const CITY_CONTEXTS: Record<string, string> = {
  'алматы': 'Almaty mountain backdrop, apple orchards, modern cafes, Medeu, Shymbulak, cosmopolitan vibe',
  'астана': 'Astana futuristic architecture, Baiterek tower, left bank modern buildings, winter capital',
  'жезказган': 'Zhezkazgan industrial heritage, copper mining history, steppe surroundings, local community spirit',
  'караганда': 'Karaganda coal mining heritage, cultural diversity, industrial strength',
  'шымкент': 'Shymkent southern warmth, ancient city, bazaars, traditional hospitality',
  'актау': 'Aktau Caspian Sea coast, modern port city, desert meets ocean, oil industry',
  'атырау': 'Atyrau oil capital, Ural river, business center, energy industry',
  'павлодар': 'Pavlodar industrial city, Irtysh river, northern Kazakhstan',
  'семей': 'Semey historical city, Abay heritage, literary traditions',
  'костанай': 'Kostanay agricultural heartland, wheat fields, northern steppe',
  'актобе': 'Aktobe western gateway, industrial center, multicultural',
  'тараз': 'Taraz ancient city, UNESCO heritage, Silk Road history',
  'усть-каменогорск': 'Ust-Kamenogorsk Altai mountains, zinc industry, natural beauty',
  'кызылорда': 'Kyzylorda rice cultivation, Baikonur proximity, Syr Darya river',
  'туркестан': 'Turkestan spiritual capital, Khoja Ahmed Yasawi mausoleum, pilgrimage site',
};

// Get Gemini client
function getGeminiClient() {
  const apiKey = process.env.GEMINI_API_KEY || process.env.API_KEY || '';
  if (!apiKey) {
    throw new Error('Gemini API key not configured. Set GEMINI_API_KEY environment variable.');
  }
  return new GoogleGenerativeAI(apiKey);
}

// Check if Gemini is available
export function isGeminiAvailable(): boolean {
  const apiKey = process.env.GEMINI_API_KEY || process.env.API_KEY || '';
  return !!apiKey;
}

// Get city context from location string
function getCityContext(location: string): string {
  const locationLower = location.toLowerCase();
  for (const [city, context] of Object.entries(CITY_CONTEXTS)) {
    if (locationLower.includes(city)) {
      return context;
    }
  }
  return 'Kazakhstan local venue, regional character, community event';
}

// Refine event details using Gemini
export async function refineEventDetails(input: PosterGenerationRequest): Promise<RefinedEventDetails> {
  const ai = getGeminiClient();
  const model = ai.getGenerativeModel({ model: 'gemini-2.0-flash' });

  const themeConfig = THEME_CONFIGS[input.theme] || THEME_CONFIGS['modern-nomad'];
  const cityContext = getCityContext(input.location);

  const prompt = `Ты — ведущий креативный директор платформы 'KZ Connect'.
Твоя задача: превратить входящие данные в стильный текст для афиши события в Казахстане.

Входящие данные:
- Название: ${input.title}
- Дата: ${input.date}
- Локация: ${input.location}
- Описание: ${input.description || 'Не указано'}
- Тема: ${themeConfig.name}

Контекст города: ${cityContext}

Инструкции:
1. Создай привлекательный tagline (слоган) для события - короткий, запоминающийся, на русском языке
2. Улучши описание, сделай его кратким но информативным
3. Если локация неточная, предложи конкретное место в этом городе
4. Сгенерируй детальный 'imagePrompt' на АНГЛИЙСКОМ языке для генерации фонового изображения:
   - Визуальный стиль: ${themeConfig.visualStyle}
   - Цветовая гамма: ${themeConfig.colors}
   - Добавь элементы, связанные с городом и контекстом
   - ВАЖНО: Если нужен текст на изображении, используй ТОЛЬКО кириллический шрифт
   - Добавь в промпт: "Cyrillic text only, professional Russian typography, clear readable Cyrillic letters"
   - Формат: вертикальный постер 9:16

Верни ТОЛЬКО JSON без markdown форматирования:
{
  "title": "улучшенное название",
  "tagline": "слоган на русском",
  "date": "форматированная дата",
  "location": "уточнённая локация",
  "description": "краткое описание",
  "theme": "${themeConfig.name}",
  "imagePrompt": "detailed english prompt for image generation"
}`;

  const result = await model.generateContent(prompt);
  const response = result.response;
  const text = response.text();

  // Parse JSON from response (handle potential markdown wrapping)
  let jsonStr = text;
  if (text.includes('```json')) {
    jsonStr = text.replace(/```json\n?/g, '').replace(/```\n?/g, '');
  } else if (text.includes('```')) {
    jsonStr = text.replace(/```\n?/g, '');
  }

  try {
    return JSON.parse(jsonStr.trim());
  } catch (e) {
    // Fallback if parsing fails
    return {
      title: input.title,
      tagline: `${input.title} в ${input.location}`,
      date: input.date,
      location: input.location,
      description: input.description || '',
      theme: themeConfig.name,
      imagePrompt: `Professional event poster background, ${themeConfig.visualStyle}, ${themeConfig.colors}, ${cityContext}, cinematic lighting, 9:16 vertical format. If text present: Cyrillic only, professional Russian typography, clear readable Cyrillic letters`,
    };
  }
}

// Generate poster background image using Gemini/Imagen
export async function generatePosterBackground(prompt: string): Promise<string> {
  const apiKey = process.env.GEMINI_API_KEY || process.env.API_KEY || '';
  if (!apiKey) {
    throw new Error('Gemini API key not configured');
  }

  const enhancedPrompt = `Professional high-end cinematic poster background: ${prompt}.
Cinematic lighting, 8k resolution, artistic composition.
CRITICAL TEXT REQUIREMENTS: If any text is present, it MUST be in Cyrillic (Russian) alphabet only.
Use professional Russian typography with clear, readable Cyrillic letters (А-Я, а-я).
NO Latin letters. NO mixed alphabets. High-quality Cyrillic font rendering.
Reflect the unique atmosphere and aesthetics of modern Kazakhstan.
Vertical 9:16 aspect ratio.`;

  // Models to try in order of preference (2025-2026 models)
  const imageModels = [
    // Gemini 2.5 Flash Image (Nano Banana) - fast image generation
    { name: 'gemini-2.5-flash-preview-04-17', method: 'generateContent', useResponseModalities: true },
    // Imagen 4 models
    { name: 'imagen-4.0-generate-preview-05-20', method: 'predict', useResponseModalities: false },
    // Fallback to older stable models
    { name: 'gemini-2.0-flash', method: 'generateContent', useResponseModalities: true },
  ];

  let lastError: string = '';

  for (const modelConfig of imageModels) {
    try {
      if (modelConfig.method === 'generateContent') {
        // Gemini native image generation
        const response = await fetch(
          `https://generativelanguage.googleapis.com/v1beta/models/${modelConfig.name}:generateContent?key=${apiKey}`,
          {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents: [{
                parts: [{ text: `Generate a professional event poster image: ${enhancedPrompt}` }]
              }],
              generationConfig: modelConfig.useResponseModalities
                ? { responseModalities: ['IMAGE', 'TEXT'] }
                : {},
            }),
          }
        );

        if (response.ok) {
          const data = await response.json();
          const parts = data.candidates?.[0]?.content?.parts || [];
          for (const part of parts) {
            if (part.inlineData?.data) {
              const mimeType = part.inlineData.mimeType || 'image/png';
              return `data:${mimeType};base64,${part.inlineData.data}`;
            }
          }
        } else {
          const errorData = await response.json().catch(() => ({}));
          lastError = errorData.error?.message || `Model ${modelConfig.name} returned ${response.status}`;
        }
      } else if (modelConfig.method === 'predict') {
        // Imagen API
        const response = await fetch(
          `https://generativelanguage.googleapis.com/v1beta/models/${modelConfig.name}:predict?key=${apiKey}`,
          {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              instances: [{ prompt: enhancedPrompt }],
              parameters: {
                sampleCount: 1,
                aspectRatio: '9:16',
                safetyFilterLevel: 'block_few',
              },
            }),
          }
        );

        if (response.ok) {
          const data = await response.json();
          if (data.predictions?.[0]?.bytesBase64Encoded) {
            return `data:image/png;base64,${data.predictions[0].bytesBase64Encoded}`;
          }
        } else {
          const errorData = await response.json().catch(() => ({}));
          lastError = errorData.error?.message || `Model ${modelConfig.name} returned ${response.status}`;
        }
      }
    } catch (e) {
      lastError = e instanceof Error ? e.message : 'Unknown error';
      continue;
    }
  }

  // All models failed
  throw new Error(
    `Не удалось сгенерировать изображение. ${lastError}. ` +
    'Попробуйте загрузить своё изображение или повторите попытку позже.'
  );
}

// Full poster generation pipeline
export async function generatePoster(request: PosterGenerationRequest): Promise<PosterGenerationResult> {
  // Step 1: Refine event details with AI
  const refinedDetails = await refineEventDetails(request);

  // Step 2: Generate background image
  const imageUrl = await generatePosterBackground(refinedDetails.imagePrompt);

  return {
    imageUrl,
    details: refinedDetails,
    isAiGenerated: true,
    aiDisclaimer: AI_DISCLAIMER_RU,
    generatedAt: new Date().toISOString(),
    provider: 'gemini',
  };
}

// Get available themes
export function getAvailableThemes(): Array<{ id: PosterTheme; name: string; description: string }> {
  return [
    { id: 'modern-nomad', name: 'Modern Nomad', description: 'Этно-футуризм — традиции в современном прочтении' },
    { id: 'urban-pulse', name: 'Urban Pulse', description: 'Мегаполис — энергия большого города' },
    { id: 'great-steppe', name: 'Great Steppe', description: 'Великая степь — природа и простор' },
    { id: 'cyber-shanyrak', name: 'Cyber Shanyrak', description: 'Технологии — цифровое будущее' },
    { id: 'silk-road', name: 'Silk Road', description: 'Шёлковый путь — классика и история' },
  ];
}

// ============================================
// Video Generation with Veo 2
// ============================================

// Video-specific motion styles for each theme
const VIDEO_THEME_MOTION: Record<PosterTheme, string> = {
  'modern-nomad': 'slow elegant camera movement, traditional patterns gently animating, subtle wind effects on fabrics',
  'urban-pulse': 'dynamic camera movement through city, lights flickering, traffic motion blur, cinematic dolly shots',
  'great-steppe': 'sweeping panoramic shot across steppe, clouds moving, grass swaying, eagles soaring',
  'cyber-shanyrak': 'digital particles flowing, holographic elements morphing, tech interfaces animating',
  'silk-road': 'gentle camera drift through historical scenes, fabric textures flowing, candlelight flickering',
};

/**
 * Generate video prompt from event details
 */
function generateVideoPrompt(details: RefinedEventDetails, aspectRatio: string): string {
  const theme = details.theme.toLowerCase().replace(' ', '-') as PosterTheme;
  const themeConfig = THEME_CONFIGS[theme] || THEME_CONFIGS['modern-nomad'];
  const motionStyle = VIDEO_THEME_MOTION[theme] || VIDEO_THEME_MOTION['modern-nomad'];

  return `Cinematic promotional video for "${details.title}" event.
${details.imagePrompt}.
Motion style: ${motionStyle}.
Color palette: ${themeConfig.colors}.
${aspectRatio === '9:16' ? 'Vertical mobile format, designed for social media stories.' : 'Widescreen cinematic format.'}
Smooth camera movement, professional quality, atmospheric lighting.
CRITICAL TEXT REQUIREMENTS: If any text appears in the video, it MUST be in Cyrillic (Russian) only.
Use professional Russian typography with clear readable Cyrillic letters (А-Я, а-я).
NO Latin letters or mixed alphabets. High-quality Cyrillic text rendering.
Reflecting the unique culture and aesthetics of modern Kazakhstan.`;
}

/**
 * Generate promotional video using Google Veo 2
 * Requires Gemini API key with Veo access
 */
export async function generatePromotionalVideo(request: VideoGenerationRequest): Promise<VideoGenerationResult> {
  const apiKey = process.env.GEMINI_API_KEY || process.env.API_KEY || '';
  if (!apiKey) {
    throw new Error('Gemini API key not configured');
  }

  // Step 1: Refine event details for video
  const refinedDetails = await refineEventDetails(request);

  // Step 2: Generate video prompt
  const aspectRatio = request.aspectRatio || '16:9';
  const duration = request.duration || '8s';
  const videoPrompt = generateVideoPrompt(refinedDetails, aspectRatio);

  // Step 3: Call Veo 2 API
  // Note: Veo 2 uses a different endpoint structure
  const veoEndpoint = 'https://generativelanguage.googleapis.com/v1beta/models/veo-2.0-generate-exp:generateVideo';

  const requestBody: Record<string, unknown> = {
    prompt: videoPrompt,
    config: {
      aspectRatio: aspectRatio,
      numberOfVideos: 1,
      durationSeconds: parseInt(duration),
      personGeneration: 'allow_adult', // For event attendees
    },
  };

  // If source image provided (image-to-video)
  if (request.sourceImage) {
    requestBody.image = {
      bytesBase64Encoded: request.sourceImage.replace(/^data:image\/\w+;base64,/, ''),
    };
  }

  try {
    const response = await fetch(`${veoEndpoint}?key=${apiKey}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(error.error?.message || `Veo API error: ${response.status}`);
    }

    const result = await response.json();

    // Veo returns an operation that needs polling
    if (result.name) {
      // Long-running operation - poll for completion
      const videoData = await pollVideoGeneration(result.name, apiKey);
      return {
        videoUrl: videoData.videoUrl,
        thumbnailUrl: videoData.thumbnailUrl,
        duration,
        aspectRatio,
        details: refinedDetails,
        isAiGenerated: true,
        aiDisclaimer: AI_VIDEO_DISCLAIMER_RU,
        generatedAt: new Date().toISOString(),
        provider: 'gemini-veo',
      };
    }

    // Direct response (if available)
    if (result.generatedVideos?.[0]?.video) {
      const videoBase64 = result.generatedVideos[0].video.bytesBase64Encoded;
      return {
        videoUrl: `data:video/mp4;base64,${videoBase64}`,
        duration,
        aspectRatio,
        details: refinedDetails,
        isAiGenerated: true,
        aiDisclaimer: AI_VIDEO_DISCLAIMER_RU,
        generatedAt: new Date().toISOString(),
        provider: 'gemini-veo',
      };
    }

    throw new Error('Unexpected response format from Veo API');
  } catch (error) {
    // Fallback error message
    const message = error instanceof Error ? error.message : 'Video generation failed';
    throw new Error(`Не удалось сгенерировать видео: ${message}`);
  }
}

/**
 * Poll for video generation completion (Veo uses async operations)
 */
async function pollVideoGeneration(
  operationName: string,
  apiKey: string,
  maxAttempts = 60,
  intervalMs = 5000
): Promise<{ videoUrl: string; thumbnailUrl?: string }> {
  const pollEndpoint = `https://generativelanguage.googleapis.com/v1beta/${operationName}?key=${apiKey}`;

  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    const response = await fetch(pollEndpoint);
    const result = await response.json();

    if (result.done) {
      if (result.error) {
        throw new Error(result.error.message || 'Video generation failed');
      }

      if (result.response?.generatedVideos?.[0]) {
        const video = result.response.generatedVideos[0];
        return {
          videoUrl: video.video?.uri || `data:video/mp4;base64,${video.video?.bytesBase64Encoded}`,
          thumbnailUrl: video.thumbnail?.uri,
        };
      }

      throw new Error('No video in completed operation');
    }

    // Wait before next poll
    await new Promise(resolve => setTimeout(resolve, intervalMs));
  }

  throw new Error('Video generation timeout - please try again');
}

/**
 * Check if video generation is available
 */
export function isVideoGenerationAvailable(): boolean {
  const apiKey = process.env.GEMINI_API_KEY || process.env.API_KEY || '';
  // Veo requires special access - check for env flag
  const veoEnabled = process.env.VEO_ENABLED === 'true';
  return !!apiKey && veoEnabled;
}

/**
 * Get video generation capabilities
 */
export function getVideoCapabilities(): {
  available: boolean;
  maxDuration: string;
  aspectRatios: string[];
  features: string[];
} {
  return {
    available: isVideoGenerationAvailable(),
    maxDuration: '8s',
    aspectRatios: ['16:9', '9:16'],
    features: [
      'text-to-video',
      'image-to-video',
      'kazakhstan-themes',
      'city-context',
    ],
  };
}
